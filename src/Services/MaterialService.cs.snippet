        public void BatchSyncWithRenderAppearance(Document doc, IEnumerable<Material> materials, Action<string>? logCallback = null, Action<double, string>? progressCallback = null)
        {
            var matsList = materials.ToList();
            if (!matsList.Any()) return;

            int total = matsList.Count;
            int processed = 0;
            int skipped = 0;
            int updated = 0;

            logCallback?.Invoke($"Analyzing {total} materials...");
            progressCallback?.Invoke(0, "Analyzing materials...");

            List<Material> materialsNeedingRegen = new List<Material>();

            // Phase 1: Enable Render Appearance
            using (Transaction t = new Transaction(doc, "Enable Render Appearance"))
            {
                t.Start();
                foreach (var mat in matsList)
                {
                    if (!mat.UseRenderAppearanceForShading)
                    {
                        mat.UseRenderAppearanceForShading = true;
                        materialsNeedingRegen.Add(mat);
                    }
                }
                t.Commit();
            }

            if (materialsNeedingRegen.Count > 0)
            {
                logCallback?.Invoke($"Enabling Render Appearance on {materialsNeedingRegen.Count} materials...");
                doc.Regenerate();
            }

            // Phase 2: Sync Graphics
            ElementId solidId = GetSolidFillPatternId(doc);

            using (Transaction t = new Transaction(doc, "Sync Graphics to Render Appearance"))
            {
                t.Start();

                // Disable UI update overhead for bulk ops if possible, but here we just loop
                foreach (Material mat in matsList)
                {
                    processed++;
                    if (processed % 10 == 0) // Update UI every 10 items
                        progressCallback?.Invoke((double)processed / total * 100, $"Processing: {mat.Name}");

                    Color renderColor = mat.Color;

                    // Optimization Check
                    if (IsMaterialSynced(mat, renderColor, solidId))
                    {
                        skipped++;
                        continue;
                    }

                    // Apply Update
                    mat.UserRenderAppearanceForShading = true; // Ensure it stays true
                    // Note: We use the renderColor we got from the mat properties
                    
                    mat.SurfaceForegroundPatternId = solidId; mat.SurfaceForegroundPatternColor = renderColor;
                    mat.SurfaceBackgroundPatternId = solidId; mat.SurfaceBackgroundPatternColor = renderColor;
                    mat.CutForegroundPatternId = solidId; mat.CutForegroundPatternColor = renderColor;
                    mat.CutBackgroundPatternId = solidId; mat.CutBackgroundPatternColor = renderColor;
                    
                    updated++;
                }

                t.Commit();
            }
            
            logCallback?.Invoke($"Sync Complete: {updated} updated, {skipped} skipped.");
            progressCallback?.Invoke(100, "Done");
        }

        private bool IsMaterialSynced(Material mat, Color targetColor, ElementId solidId)
        {
            if (!ColorsEqual(mat.Color, targetColor)) return false;
            
            if (mat.SurfaceForegroundPatternId != solidId) return false;
            if (!ColorsEqual(mat.SurfaceForegroundPatternColor, targetColor)) return false;

            if (mat.SurfaceBackgroundPatternId != solidId) return false;
            if (!ColorsEqual(mat.SurfaceBackgroundPatternColor, targetColor)) return false;

            if (mat.CutForegroundPatternId != solidId) return false;
            if (!ColorsEqual(mat.CutForegroundPatternColor, targetColor)) return false;

            if (mat.CutBackgroundPatternId != solidId) return false;
            if (!ColorsEqual(mat.CutBackgroundPatternColor, targetColor)) return false;

            return true;
        }

        private bool ColorsEqual(Color c1, Color c2)
        {
            if (c1 == null || c2 == null) return false;
            return c1.Red == c2.Red && c1.Green == c2.Green && c1.Blue == c2.Blue;
        }
